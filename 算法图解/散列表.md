### 散列表

散列表是最有用的基本数据结构之一，其用途广泛。内部机制主要有：实现、冲突和散列函数。

散列表（Hash table，也叫哈希表），是根据键而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

#### 散列函数

散列函数就是”将输入映射到数字“，它必须满足以下条件：

1. 总是将相同的输入映射到相同的数字
2. ~~将不同的输入映射到不同的数字~~

如果把它定义成 **hash(key)** ，其中 key 表示元素的键值，则 **hash(key)** 的值表示经过散列函数计算得到的散列值。数组和链表都被直接映射到内存，但是散列表更加复杂，它使用散列函数来确定元素的存储位置。通过数组和散列函数可以创建散列表。

Python 中提供的散列表的实现为字典，你可以使用函数 dict 来创建散列表或者快捷方式-一对大括号：

``` python
book = dict()
book['apple'] = 0.67
book['milk'] = 1.49

print(book)  # {'apple': 0.67, 'milk': 1.49}

phoneBook = {'jack': 123234, 'xiaoming': 1234}
print(phoneBook)  # {'jack': 123234, 'xiaoming': 1234}
```

散列表的用途：

- 模拟映射关系
- 防止重复
- 缓存/记住数据，以免服务器再通过处理来生成他们

#### 冲突

上述说散列函数总算是将不同的键映射到数组的不同位置。实际上这几乎是不可能的，因为对于散列表而言，无论设置的存储区域（n）有多大，当需要存储的数据大于 n 时，那么必然会存在哈希值相同的情况。这就是所谓的**散列冲突**。

最简单的解决办法：如果两个键映射到了同一位置，就在这个位置上存储一个链表。如果这链表很短，那么也没什么关系，只需搜索三四个元素即可，如果这个链表很长，而散列表中的其他位置被浪费了，那么散列表的速度会很慢。

#### 性能

这里列举了散列表和数组以及链表的时时间复杂度比较：

|      | 散列表（平均情况） | 散列表（最坏情况） | 数组 | 链表 |
| ---- | ------------------ | ------------------ | ---- | ---- |
| 查找 | O(1)               | O(n)               | O(1) | O(n) |
| 插入 | O(1)               | O(n)               | O(n) | O(1) |
| 删除 | O(1)               | O(n)               | O(n) | O(1) |

在平均情况下，散列表兼具数组和列表的有点，但是在最坏情况下，其各种操作都很慢。因此在使用散列表要避免最坏情况吗，也就是需要避免冲突。而需要避免冲突，需要有：

- 较低的填装因子
- 良好的散列函数

**填装因子**

填装因子=散列表包含的元素数/位置总数​

如下列散列表的填装因子为 2/5，即0.4。

![image-20200401175649652](https://raw.githubusercontent.com/recoveryMonster/HexoImages/master/Gridea/20200401180343.png)

一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为*调整长度*。

填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就要调整填装因子的长度。

**良好的散列函数**

良好的散列函数而让数组中的值呈均匀分布，而不是让值扎堆，导致大量冲突。