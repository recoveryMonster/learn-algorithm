### 选择排序

当需要存储多项数据时，有两种基本方式—数组和链表。

**数组和链表**

**数组**在内存中存的地址必须是相连的（紧靠在一起的），因此如果要往数组中添加新元素，如果其后面的内存位置被使用，则需要请求计算机重新分配一块连续的内存地址，将数组中的所有元素和新元素添加到新的内存地址中，因此添加新元素的速度会很慢。

为了解决数组添加元素速度慢的问题，有两种方法可以解决：

1. 预留内存，当数组中只有三个元素是，我们可以提前设置数组的长度为10 ，从而只要数组的元素不超过10个，就无需进行重新分配复制，但这种方法会浪费内存，并且数组添加的元素不能超过10个。
2. 使用链表。

**链表：**每个元素都存储了下一个元素的位置，从而使一系列随机的内存地址串在一起，其在插入元素方面具有优势，但读取其中的某个元素的速度会很慢，因为你不能直接读取，你不知道其所处的地址，必须访问元素#1，从中获得元素#2的地址，以此类推，直到访问到所需元素的地址，因此如果需要同时读取所有的元素，链表的效率会很高。而如果需要跳跃读取，链表的效率会很低。

数组在随机读取元素的时候，效率很高，因为可以迅速的找到数组的任何元素。

**常见的数组和链表操作的运行时间**

|      | 数组 | 链表 |
| ---- | ---- | ---- |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

注：O(n) = 线性时间     O(1) = 常量时间 

**在中间插入：**使用链表时，插入元素很简单，只需修改其前面的元素指向的地址；而数组需要将后面所有的元素后移，如果没有足够的空间，还得将整个数组复制到其他地方。因此链表是更好的选择。

**删除：**链表也是更好的选择，因为只需要修改前一个元素指向的地址即可。而使用数组删除之后，必须将后面的元素都向前移。

由于数组支持随机访问，而链表只支持顺序访问，因此数组用的比较多。所谓*顺序访问* 意味着从第一个元素开始逐个的读取元素。

**选择排序**

对一组数据进行遍历排序，第一次遍历获得第一个值，第二次遍历获得第二个值，因此需要检查的元素为 `n * (n-1)*...*1` 因此运行时间为 O(n x 1/2 x n) 即 O($n^2$)。

示例代码。如数组从小到大排序。

``` python
def findSmallest(arr):  # 找到数组中最小的元素
    smallest = arr[0]  # 存储最小的值
    smallest_index = 0  # 存储最小元素的索引
    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index


def selectionSort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest = findSmallest(arr)  # 找出元素中最小的元素并将其加入到新的数组中
        newArr.append(arr.pop(smallest))
    return newArr


print(selectionSort([5, 3, 6, 2, 10]))
```

