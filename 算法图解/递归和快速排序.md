### 递归和快速排序

**递归**只是让解决方案更清晰，并没有性能上的优势。实际上，在某些情况下，使用循环的性能更好。每个递归函数都由基线条件（ base case ）和递归条件（ recursive case ）。递归条件指的是函数调用自己，而基线条件则指的是函数不在调用自己，从而避免形成无限循环。

**栈**是一种数据结构，只有两种操作，压入和弹出。在计算机中，所有函数的调用都会进入调用栈，调用栈可能很长，这将占用大量的内存。这种情况下，有以下两种选择：

- 重新编写代码，转而使用循环。
- 使用尾递归，注意并非所有的语言都支持尾递归。

**分而治之**（ divide and conquer, D&C ）是一种通用问题的解决方法。其主要包括两个步骤：

- 找出基线条件，这种条件必须尽可能简单。
- 不断将问题分解 ( 或者说缩小规模 )，直到符合基线条件

注意：编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是否为这样。

**快速排序**是一种常见的排序算法，其速度比选择排序快得多，也使用了 D&C。一般分为三个步骤：

- 选择基准值
- 将数组分为两个子数组：小于基准值的元素和大于基准值的元素
- 对这两个子数组进行快速排序

```python
def quickSort(array):
  # 基线条件：为空或者只包含一个元素的数组是“有序”的
    if (len(array) < 2):
        return array 
    else:
        pivot = array[0] # 基准值
        less = [i for i in array[1:] if i < pivot] #由所有小于基准值的元素
        greater = [i for i in array[1:] if i > pivot] #所有大于基准值的元素
        return quickSort(less) + [pivot] + quickSort(greater)


print(quickSort([10, 5, 2, 3]))
```

还有一种名为*合并排序*（ merge sort ）的排序算法，其运行时间为 O(n log n)，比选择排序快的多！，快速排序在最坏的情况下，其运行时间为 O($n^2$)，平均情况下运行时间为 O(n log n)。

在大 O 表示法中 O(n) 中，n 实际上是 c*n，其中 c 是算法所需的固定时间量，也就是常量。通常不考虑这两个常量，因为如果两种算法的大 O 运行时间不同，这两种常量将无关紧要。但有的时候，常量的影响可能很大，对于快速查找和合并查找来说就是如此。快速查找的常量比合并查找的小，因此在运行时间都为 O(n log n)的情况下 ，**快速查找的速度将更快**，因为它遇上平均情况的可能性要大的多。

比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n) 的速度比 O(n) 快的多。